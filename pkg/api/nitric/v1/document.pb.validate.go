// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: document/v1/document.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
)

// Validate checks the field values on Collection with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Collection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Collection with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CollectionMultiError, or
// nil if none found.
func (m *Collection) ValidateAll() error {
	return m.validate(true)
}

func (m *Collection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetName()) > 256 {
		err := CollectionValidationError{
			field:  "Name",
			reason: "value length must be at most 256 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Collection_Name_Pattern.MatchString(m.GetName()) {
		err := CollectionValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^\\\\w+([.\\\\-]\\\\w+)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetParent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionValidationError{
					field:  "Parent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionValidationError{
					field:  "Parent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionValidationError{
				field:  "Parent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CollectionMultiError(errors)
	}
	return nil
}

// CollectionMultiError is an error wrapping multiple validation errors
// returned by Collection.ValidateAll() if the designated constraints aren't met.
type CollectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionMultiError) AllErrors() []error { return m }

// CollectionValidationError is the validation error returned by
// Collection.Validate if the designated constraints aren't met.
type CollectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionValidationError) ErrorName() string { return "CollectionValidationError" }

// Error satisfies the builtin error interface
func (e CollectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionValidationError{}

var _Collection_Name_Pattern = regexp.MustCompile("^\\w+([.\\-]\\w+)*$")

// Validate checks the field values on Key with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Key) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Key with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in KeyMultiError, or nil if none found.
func (m *Key) ValidateAll() error {
	return m.validate(true)
}

func (m *Key) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCollection() == nil {
		err := KeyValidationError{
			field:  "Collection",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCollection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCollection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyValidationError{
				field:  "Collection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetId()); l < 1 || l > 256 {
		err := KeyValidationError{
			field:  "Id",
			reason: "value length must be between 1 and 256 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return KeyMultiError(errors)
	}
	return nil
}

// KeyMultiError is an error wrapping multiple validation errors returned by
// Key.ValidateAll() if the designated constraints aren't met.
type KeyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyMultiError) AllErrors() []error { return m }

// KeyValidationError is the validation error returned by Key.Validate if the
// designated constraints aren't met.
type KeyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyValidationError) ErrorName() string { return "KeyValidationError" }

// Error satisfies the builtin error interface
func (e KeyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKey.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyValidationError{}

// Validate checks the field values on Document with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Document) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Document with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DocumentMultiError, or nil
// if none found.
func (m *Document) ValidateAll() error {
	return m.validate(true)
}

func (m *Document) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetContent() == nil {
		err := DocumentValidationError{
			field:  "Content",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetKey() == nil {
		err := DocumentValidationError{
			field:  "Key",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentValidationError{
				field:  "Key",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentMultiError(errors)
	}
	return nil
}

// DocumentMultiError is an error wrapping multiple validation errors returned
// by Document.ValidateAll() if the designated constraints aren't met.
type DocumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentMultiError) AllErrors() []error { return m }

// DocumentValidationError is the validation error returned by
// Document.Validate if the designated constraints aren't met.
type DocumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentValidationError) ErrorName() string { return "DocumentValidationError" }

// Error satisfies the builtin error interface
func (e DocumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentValidationError{}

// Validate checks the field values on ExpressionValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExpressionValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpressionValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpressionValueMultiError, or nil if none found.
func (m *ExpressionValue) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpressionValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Kind.(type) {

	case *ExpressionValue_IntValue:
		// no validation rules for IntValue

	case *ExpressionValue_DoubleValue:
		// no validation rules for DoubleValue

	case *ExpressionValue_StringValue:
		// no validation rules for StringValue

	case *ExpressionValue_BoolValue:
		// no validation rules for BoolValue

	}

	if len(errors) > 0 {
		return ExpressionValueMultiError(errors)
	}
	return nil
}

// ExpressionValueMultiError is an error wrapping multiple validation errors
// returned by ExpressionValue.ValidateAll() if the designated constraints
// aren't met.
type ExpressionValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpressionValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpressionValueMultiError) AllErrors() []error { return m }

// ExpressionValueValidationError is the validation error returned by
// ExpressionValue.Validate if the designated constraints aren't met.
type ExpressionValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpressionValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpressionValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpressionValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpressionValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpressionValueValidationError) ErrorName() string { return "ExpressionValueValidationError" }

// Error satisfies the builtin error interface
func (e ExpressionValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpressionValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpressionValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpressionValueValidationError{}

// Validate checks the field values on Expression with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Expression) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Expression with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpressionMultiError, or
// nil if none found.
func (m *Expression) ValidateAll() error {
	return m.validate(true)
}

func (m *Expression) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Operand

	if _, ok := _Expression_Operator_InLookup[m.GetOperator()]; !ok {
		err := ExpressionValidationError{
			field:  "Operator",
			reason: "value must be in list [== < <= > >= startsWith]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetValue() == nil {
		err := ExpressionValidationError{
			field:  "Value",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpressionValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpressionValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpressionValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExpressionMultiError(errors)
	}
	return nil
}

// ExpressionMultiError is an error wrapping multiple validation errors
// returned by Expression.ValidateAll() if the designated constraints aren't met.
type ExpressionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpressionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpressionMultiError) AllErrors() []error { return m }

// ExpressionValidationError is the validation error returned by
// Expression.Validate if the designated constraints aren't met.
type ExpressionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpressionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpressionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpressionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpressionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpressionValidationError) ErrorName() string { return "ExpressionValidationError" }

// Error satisfies the builtin error interface
func (e ExpressionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpression.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpressionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpressionValidationError{}

var _Expression_Operator_InLookup = map[string]struct{}{
	"==":         {},
	"<":          {},
	"<=":         {},
	">":          {},
	">=":         {},
	"startsWith": {},
}

// Validate checks the field values on DocumentGetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentGetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentGetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentGetRequestMultiError, or nil if none found.
func (m *DocumentGetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentGetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetKey() == nil {
		err := DocumentGetRequestValidationError{
			field:  "Key",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentGetRequestValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentGetRequestValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentGetRequestValidationError{
				field:  "Key",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentGetRequestMultiError(errors)
	}
	return nil
}

// DocumentGetRequestMultiError is an error wrapping multiple validation errors
// returned by DocumentGetRequest.ValidateAll() if the designated constraints
// aren't met.
type DocumentGetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentGetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentGetRequestMultiError) AllErrors() []error { return m }

// DocumentGetRequestValidationError is the validation error returned by
// DocumentGetRequest.Validate if the designated constraints aren't met.
type DocumentGetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentGetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentGetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentGetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentGetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentGetRequestValidationError) ErrorName() string {
	return "DocumentGetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentGetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentGetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentGetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentGetRequestValidationError{}

// Validate checks the field values on DocumentGetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentGetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentGetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentGetResponseMultiError, or nil if none found.
func (m *DocumentGetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentGetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDocument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentGetResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentGetResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentGetResponseValidationError{
				field:  "Document",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentGetResponseMultiError(errors)
	}
	return nil
}

// DocumentGetResponseMultiError is an error wrapping multiple validation
// errors returned by DocumentGetResponse.ValidateAll() if the designated
// constraints aren't met.
type DocumentGetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentGetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentGetResponseMultiError) AllErrors() []error { return m }

// DocumentGetResponseValidationError is the validation error returned by
// DocumentGetResponse.Validate if the designated constraints aren't met.
type DocumentGetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentGetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentGetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentGetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentGetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentGetResponseValidationError) ErrorName() string {
	return "DocumentGetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentGetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentGetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentGetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentGetResponseValidationError{}

// Validate checks the field values on DocumentSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentSetRequestMultiError, or nil if none found.
func (m *DocumentSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetKey() == nil {
		err := DocumentSetRequestValidationError{
			field:  "Key",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentSetRequestValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentSetRequestValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentSetRequestValidationError{
				field:  "Key",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetContent() == nil {
		err := DocumentSetRequestValidationError{
			field:  "Content",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentSetRequestValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentSetRequestValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentSetRequestValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentSetRequestMultiError(errors)
	}
	return nil
}

// DocumentSetRequestMultiError is an error wrapping multiple validation errors
// returned by DocumentSetRequest.ValidateAll() if the designated constraints
// aren't met.
type DocumentSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentSetRequestMultiError) AllErrors() []error { return m }

// DocumentSetRequestValidationError is the validation error returned by
// DocumentSetRequest.Validate if the designated constraints aren't met.
type DocumentSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentSetRequestValidationError) ErrorName() string {
	return "DocumentSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentSetRequestValidationError{}

// Validate checks the field values on DocumentSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentSetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentSetResponseMultiError, or nil if none found.
func (m *DocumentSetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentSetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DocumentSetResponseMultiError(errors)
	}
	return nil
}

// DocumentSetResponseMultiError is an error wrapping multiple validation
// errors returned by DocumentSetResponse.ValidateAll() if the designated
// constraints aren't met.
type DocumentSetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentSetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentSetResponseMultiError) AllErrors() []error { return m }

// DocumentSetResponseValidationError is the validation error returned by
// DocumentSetResponse.Validate if the designated constraints aren't met.
type DocumentSetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentSetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentSetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentSetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentSetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentSetResponseValidationError) ErrorName() string {
	return "DocumentSetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentSetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentSetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentSetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentSetResponseValidationError{}

// Validate checks the field values on DocumentDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentDeleteRequestMultiError, or nil if none found.
func (m *DocumentDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetKey() == nil {
		err := DocumentDeleteRequestValidationError{
			field:  "Key",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentDeleteRequestValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentDeleteRequestValidationError{
					field:  "Key",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentDeleteRequestValidationError{
				field:  "Key",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentDeleteRequestMultiError(errors)
	}
	return nil
}

// DocumentDeleteRequestMultiError is an error wrapping multiple validation
// errors returned by DocumentDeleteRequest.ValidateAll() if the designated
// constraints aren't met.
type DocumentDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentDeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentDeleteRequestMultiError) AllErrors() []error { return m }

// DocumentDeleteRequestValidationError is the validation error returned by
// DocumentDeleteRequest.Validate if the designated constraints aren't met.
type DocumentDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentDeleteRequestValidationError) ErrorName() string {
	return "DocumentDeleteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentDeleteRequestValidationError{}

// Validate checks the field values on DocumentDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentDeleteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentDeleteResponseMultiError, or nil if none found.
func (m *DocumentDeleteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentDeleteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DocumentDeleteResponseMultiError(errors)
	}
	return nil
}

// DocumentDeleteResponseMultiError is an error wrapping multiple validation
// errors returned by DocumentDeleteResponse.ValidateAll() if the designated
// constraints aren't met.
type DocumentDeleteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentDeleteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentDeleteResponseMultiError) AllErrors() []error { return m }

// DocumentDeleteResponseValidationError is the validation error returned by
// DocumentDeleteResponse.Validate if the designated constraints aren't met.
type DocumentDeleteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentDeleteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentDeleteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentDeleteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentDeleteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentDeleteResponseValidationError) ErrorName() string {
	return "DocumentDeleteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentDeleteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentDeleteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentDeleteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentDeleteResponseValidationError{}

// Validate checks the field values on DocumentQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentQueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentQueryRequestMultiError, or nil if none found.
func (m *DocumentQueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentQueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCollection() == nil {
		err := DocumentQueryRequestValidationError{
			field:  "Collection",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCollection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentQueryRequestValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentQueryRequestValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCollection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentQueryRequestValidationError{
				field:  "Collection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExpressions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentQueryRequestValidationError{
						field:  fmt.Sprintf("Expressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentQueryRequestValidationError{
						field:  fmt.Sprintf("Expressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentQueryRequestValidationError{
					field:  fmt.Sprintf("Expressions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Limit

	// no validation rules for PagingToken

	if len(errors) > 0 {
		return DocumentQueryRequestMultiError(errors)
	}
	return nil
}

// DocumentQueryRequestMultiError is an error wrapping multiple validation
// errors returned by DocumentQueryRequest.ValidateAll() if the designated
// constraints aren't met.
type DocumentQueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentQueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentQueryRequestMultiError) AllErrors() []error { return m }

// DocumentQueryRequestValidationError is the validation error returned by
// DocumentQueryRequest.Validate if the designated constraints aren't met.
type DocumentQueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentQueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentQueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentQueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentQueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentQueryRequestValidationError) ErrorName() string {
	return "DocumentQueryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentQueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentQueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentQueryRequestValidationError{}

// Validate checks the field values on DocumentQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentQueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentQueryResponseMultiError, or nil if none found.
func (m *DocumentQueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentQueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDocuments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentQueryResponseValidationError{
						field:  fmt.Sprintf("Documents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentQueryResponseValidationError{
						field:  fmt.Sprintf("Documents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentQueryResponseValidationError{
					field:  fmt.Sprintf("Documents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PagingToken

	if len(errors) > 0 {
		return DocumentQueryResponseMultiError(errors)
	}
	return nil
}

// DocumentQueryResponseMultiError is an error wrapping multiple validation
// errors returned by DocumentQueryResponse.ValidateAll() if the designated
// constraints aren't met.
type DocumentQueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentQueryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentQueryResponseMultiError) AllErrors() []error { return m }

// DocumentQueryResponseValidationError is the validation error returned by
// DocumentQueryResponse.Validate if the designated constraints aren't met.
type DocumentQueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentQueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentQueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentQueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentQueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentQueryResponseValidationError) ErrorName() string {
	return "DocumentQueryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentQueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentQueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentQueryResponseValidationError{}

// Validate checks the field values on DocumentQueryStreamRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentQueryStreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentQueryStreamRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentQueryStreamRequestMultiError, or nil if none found.
func (m *DocumentQueryStreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentQueryStreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCollection() == nil {
		err := DocumentQueryStreamRequestValidationError{
			field:  "Collection",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCollection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentQueryStreamRequestValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentQueryStreamRequestValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCollection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentQueryStreamRequestValidationError{
				field:  "Collection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExpressions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentQueryStreamRequestValidationError{
						field:  fmt.Sprintf("Expressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentQueryStreamRequestValidationError{
						field:  fmt.Sprintf("Expressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentQueryStreamRequestValidationError{
					field:  fmt.Sprintf("Expressions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Limit

	if len(errors) > 0 {
		return DocumentQueryStreamRequestMultiError(errors)
	}
	return nil
}

// DocumentQueryStreamRequestMultiError is an error wrapping multiple
// validation errors returned by DocumentQueryStreamRequest.ValidateAll() if
// the designated constraints aren't met.
type DocumentQueryStreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentQueryStreamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentQueryStreamRequestMultiError) AllErrors() []error { return m }

// DocumentQueryStreamRequestValidationError is the validation error returned
// by DocumentQueryStreamRequest.Validate if the designated constraints aren't met.
type DocumentQueryStreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentQueryStreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentQueryStreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentQueryStreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentQueryStreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentQueryStreamRequestValidationError) ErrorName() string {
	return "DocumentQueryStreamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentQueryStreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentQueryStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentQueryStreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentQueryStreamRequestValidationError{}

// Validate checks the field values on DocumentQueryStreamResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentQueryStreamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentQueryStreamResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentQueryStreamResponseMultiError, or nil if none found.
func (m *DocumentQueryStreamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentQueryStreamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDocument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentQueryStreamResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentQueryStreamResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentQueryStreamResponseValidationError{
				field:  "Document",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentQueryStreamResponseMultiError(errors)
	}
	return nil
}

// DocumentQueryStreamResponseMultiError is an error wrapping multiple
// validation errors returned by DocumentQueryStreamResponse.ValidateAll() if
// the designated constraints aren't met.
type DocumentQueryStreamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentQueryStreamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentQueryStreamResponseMultiError) AllErrors() []error { return m }

// DocumentQueryStreamResponseValidationError is the validation error returned
// by DocumentQueryStreamResponse.Validate if the designated constraints
// aren't met.
type DocumentQueryStreamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentQueryStreamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentQueryStreamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentQueryStreamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentQueryStreamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentQueryStreamResponseValidationError) ErrorName() string {
	return "DocumentQueryStreamResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentQueryStreamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentQueryStreamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentQueryStreamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentQueryStreamResponseValidationError{}
